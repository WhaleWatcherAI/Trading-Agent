<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NQ ICT Strategy - Live Dashboard</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@microsoft/signalr@8.0.0/dist/browser/signalr.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f1729 0%, #1a1f3a 100%);
            color: #e2e8f0;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1a1f3a 0%, #0f1729 100%);
            padding: 1.25rem;
            border-bottom: 2px solid #667eea;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            position: relative;
            z-index: 100;
        }

        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        .header-left {
            flex: 1;
        }

        .title {
            font-size: 1.75rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.25rem;
        }

        .subtitle {
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .control-panel {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.875rem;
            letter-spacing: 0.5px;
        }

        .btn-start {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }

        .btn-start:hover:not(:disabled) {
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.6);
            transform: translateY(-2px);
        }

        .btn-stop {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(249, 115, 22, 0.4);
        }

        .btn-stop:hover {
            box-shadow: 0 6px 20px rgba(249, 115, 22, 0.6);
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .status-badge {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .status-active {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .status-inactive {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .status-bar {
            background: rgba(26, 31, 58, 0.8);
            padding: 1rem;
            border-bottom: 1px solid #2a3150;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 2rem;
            overflow-x: auto;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            white-space: nowrap;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            color: #f1f5f9;
            font-weight: 700;
            font-size: 1.125rem;
        }

        .stat-value.positive { color: #10b981; }
        .stat-value.negative { color: #ef4444; }

        .main-container {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 200px 300px;
            height: calc(100vh - 140px);
            gap: 0.5rem;
            padding: 0.5rem;
            background: #0f1729;
            overflow: hidden;
        }

        #orderbookCanvas,
        #largeOrderMarkers,
        #volumeProfileCanvas,
        #absorptionCanvas,
        #exhaustionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #orderbookCanvas { z-index: 10; }
        #volumeProfileCanvas { z-index: 12; }
        #largeOrderMarkers { z-index: 15; }
        #absorptionCanvas { z-index: 22; }
        #exhaustionCanvas { z-index: 24; }
        }

        .large-order-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .large-order-control label {
            color: #94a3b8;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .large-order-control input {
            background: rgba(51, 65, 85, 0.5);
            border: 1px solid #475569;
            border-radius: 0.375rem;
            padding: 0.375rem 0.75rem;
            color: #f1f5f9;
            font-size: 0.875rem;
            width: 100px;
        }

        .large-order-control input:focus {
            outline: none;
            border-color: #667eea;
        }

        .chart-container {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 0.5rem;
            border: 1px solid rgba(51, 65, 85, 0.5);
            padding: 1rem;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chart-title {
            color: #f1f5f9;
            font-weight: 700;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            letter-spacing: 0.5px;
        }

        .chart-wrapper {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        #mainChart {
            width: 100%;
            height: 100%;
        }

        #orderbookCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        .bottom-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .panel {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 0.5rem;
            border: 1px solid rgba(51, 65, 85, 0.5);
            padding: 1rem;
            backdrop-filter: blur(10px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            color: #f1f5f9;
            font-weight: 700;
            margin-bottom: 0.75rem;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            font-size: 0.875rem;
        }

        .position-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            padding: 0.75rem;
            background: rgba(51, 65, 85, 0.3);
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
        }

        .position-label {
            color: #94a3b8;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .position-value {
            color: #f1f5f9;
            font-weight: 600;
            margin-top: 0.25rem;
        }

        .trade-row {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid rgba(51, 65, 85, 0.3);
            display: grid;
            grid-template-columns: 60px 70px 1fr;
            gap: 0.5rem;
            align-items: center;
            font-size: 0.75rem;
        }

        .trade-side { font-weight: 700; }
        .trade-side.long { color: #10b981; }
        .trade-side.short { color: #ef4444; }

        .trade-pnl { font-weight: 700; }
        .trade-pnl.positive { color: #10b981; }
        .trade-pnl.negative { color: #ef4444; }

        .trade-info { color: #94a3b8; }

        .activity-log {
            background: rgba(30, 41, 59, 0.4);
            border-radius: 0.5rem;
            padding: 1rem;
            border: 1px solid rgba(51, 65, 85, 0.3);
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
        }

        .log-entry {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 0.25rem;
            display: flex;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .log-time { color: #94a3b8; flex: 0 0 auto; }
        .log-msg { flex: 1; }

        .log-info { color: #0284c7; }
        .log-success { color: #10b981; background: rgba(16, 185, 129, 0.1); }
        .log-warning { color: #f97316; background: rgba(249, 115, 22, 0.1); }
        .log-error { color: #ef4444; background: rgba(239, 68, 68, 0.1); }

        .no-data {
            color: #64748b;
            font-style: italic;
            padding: 1rem;
            text-align: center;
        }

        .entry-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%);
        }

        .entry-long { background: #10b981; box-shadow: 0 0 10px rgba(16, 185, 129, 0.6); }
        .entry-short { background: #ef4444; box-shadow: 0 0 10px rgba(239, 68, 68, 0.6); }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(51, 65, 85, 0.2);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.4);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.6);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .header-content { flex-direction: column; gap: 1rem; }
            .bottom-panels { grid-template-columns: 1fr; }
            .main-container { grid-template-rows: 1.5fr 350px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="header-left">
                <div class="title">NQ ICT Strategy</div>
                <div class="subtitle">Market Structure + Wicked Candles | Break of Structure Confirmation | SL=4t, TP1=16t, TP2=32t</div>
            </div>
            <div class="control-panel">
                <button id="btnStart" class="btn btn-start">‚ñ∂ START</button>
                <button id="btnStop" class="btn btn-stop" style="display: none;">‚è∏ STOP</button>
                <div id="tradingStatus" class="status-badge status-inactive">OFFLINE</div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div class="stat-item">
            <div class="stat-label">Total Trades</div>
            <div class="stat-value" id="totalTrades">0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Win Rate</div>
            <div class="stat-value" id="winRate">0%</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Total P&L</div>
            <div class="stat-value" id="totalPnL">$0</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Entry Price</div>
            <div class="stat-value" id="entryPrice">‚Äî</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Position</div>
            <div class="stat-value" id="positionStatus">NONE</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Unrealized P&L</div>
            <div class="stat-value" id="unrealizedPnL">$0</div>
        </div>
    </div>

    <div style="max-width: 1600px; margin: 0 auto; padding: 1rem; overflow-y: auto; height: calc(100vh - 140px);">
        <div style="display: grid; grid-template-columns: 1fr 320px; gap: 1rem; margin-bottom: 1rem;">
            <div style="background: #1e293b; border-radius: 0.5rem; padding: 1rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                    <div style="font-weight: 600; color: #f1f5f9;">1-Minute Price Chart | Break of Structure (BOS) | Fair Value Gaps (FVG) | Wicked Candles | Level 2 Orderbook</div>
                    <div class="large-order-control">
                        <label for="largeOrderThreshold">Large Order Threshold:</label>
                        <input type="number" id="largeOrderThreshold" value="30" min="1" step="1" />
                        <span style="color: #94a3b8; font-size: 0.875rem;">contracts</span>
                    </div>
                </div>
                <div style="height: 450px; width: 100%; position: relative;">
                    <div id="mainChart" style="height: 100%; width: 100%;"></div>
                    <canvas id="orderbookCanvas"></canvas>
                    <canvas id="volumeProfileCanvas"></canvas>
                    <canvas id="largeOrderMarkers"></canvas>
                    <canvas id="absorptionCanvas"></canvas>
                    <canvas id="exhaustionCanvas"></canvas>
                </div>
            </div>

            <div style="background: #1e293b; border-radius: 0.5rem; padding: 1rem;">
                <div style="font-weight: 600; color: #f1f5f9; margin-bottom: 0.75rem; border-bottom: 2px solid #667eea; padding-bottom: 0.5rem;">üìä Chart Legend</div>

                <div style="margin-bottom: 1.25rem;">
                    <div style="font-weight: 600; color: #94a3b8; font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Candlesticks</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.375rem;">
                        <div style="width: 16px; height: 16px; background: #10b981; border: 1px solid #059669;"></div>
                        <span style="color: #cbd5e1; font-size: 0.875rem;">Green = Bullish (Close > Open)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <div style="width: 16px; height: 16px; background: #ef4444; border: 1px solid #dc2626;"></div>
                        <span style="color: #cbd5e1; font-size: 0.875rem;">Red = Bearish (Close < Open)</span>
                    </div>
                </div>

                <div style="margin-bottom: 1.25rem;">
                    <div style="font-weight: 600; color: #94a3b8; font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Level 2 Orderbook</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.375rem;">
                        <div style="width: 30px; height: 8px; background: rgba(16, 185, 129, 0.4);"></div>
                        <span style="color: #cbd5e1; font-size: 0.875rem;">Bid Orders (Buy Side)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <div style="width: 30px; height: 8px; background: rgba(239, 68, 68, 0.4);"></div>
                        <span style="color: #cbd5e1; font-size: 0.875rem;">Ask Orders (Sell Side)</span>
                    </div>
                </div>

                <div style="margin-bottom: 1.25rem;">
                    <div style="font-weight: 600; color: #94a3b8; font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Volume Profile</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.375rem;">
                        <div style="width: 24px; height: 6px; background: rgba(148, 163, 184, 0.6);"></div>
                        <span style="color: #cbd5e1; font-size: 0.8rem;">Horizontal bars (left) = traded volume by price since 6:00pm ET session start</span>
                    </div>
                </div>

                <div style="margin-bottom: 1.25rem;">
                    <div style="font-weight: 600; color: #94a3b8; font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Lines & Levels</div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.375rem;">
                        <div style="width: 30px; height: 2px; border-top: 2px dashed #10b981;"></div>
                        <span style="color: #cbd5e1; font-size: 0.875rem;">BOS High (Resistance)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <div style="width: 30px; height: 2px; border-top: 2px dashed #ef4444;"></div>
                        <span style="color: #cbd5e1; font-size: 0.875rem;">BOS Low (Support)</span>
                    </div>
                </div>

                <div style="margin-bottom: 1.25rem;">
                    <div style="font-weight: 600; color: #94a3b8; font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Strategy Terms</div>
                    <div style="margin-bottom: 0.5rem;">
                        <div style="color: #f1f5f9; font-weight: 600; font-size: 0.875rem;">BOS (Break of Structure)</div>
                        <div style="color: #94a3b8; font-size: 0.75rem; line-height: 1.4;">Price breaks recent high/low = trend shift</div>
                    </div>
                    <div style="margin-bottom: 0.5rem;">
                        <div style="color: #f1f5f9; font-weight: 600; font-size: 0.875rem;">Wicked Candle</div>
                        <div style="color: #94a3b8; font-size: 0.75rem; line-height: 1.4;">Long wick (‚â•70% of range) = rejection</div>
                    </div>
                    <div style="margin-bottom: 0.5rem;">
                        <div style="color: #f1f5f9; font-weight: 600; font-size: 0.875rem;">FVG (Fair Value Gap)</div>
                        <div style="color: #94a3b8; font-size: 0.75rem; line-height: 1.4;">Price gap between candles = imbalance</div>
                    </div>
                </div>

                <div style="margin-bottom: 1.25rem;">
                    <div style="font-weight: 600; color: #94a3b8; font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Entry Signals</div>
                    <div style="background: rgba(16, 185, 129, 0.1); border-left: 3px solid #10b981; padding: 0.5rem; margin-bottom: 0.375rem; border-radius: 0.25rem;">
                        <div style="color: #10b981; font-weight: 600; font-size: 0.875rem;">LONG</div>
                        <div style="color: #94a3b8; font-size: 0.75rem;">Bullish Wicked + Bullish BOS</div>
                    </div>
                    <div style="background: rgba(239, 68, 68, 0.1); border-left: 3px solid #ef4444; padding: 0.5rem; border-radius: 0.25rem;">
                        <div style="color: #ef4444; font-weight: 600; font-size: 0.875rem;">SHORT</div>
                        <div style="color: #94a3b8; font-size: 0.75rem;">Bearish Wicked + Bearish BOS</div>
                    </div>
                </div>

                <div>
                    <div style="font-weight: 600; color: #94a3b8; font-size: 0.75rem; margin-bottom: 0.5rem; text-transform: uppercase;">Risk Management</div>
                    <div style="color: #cbd5e1; font-size: 0.875rem; line-height: 1.6;">
                        <div>‚Ä¢ <strong>Stop Loss:</strong> 4 ticks</div>
                        <div>‚Ä¢ <strong>TP1:</strong> 16 ticks (50% exit)</div>
                        <div>‚Ä¢ <strong>TP2:</strong> 32 ticks (50% exit)</div>
                        <div style="margin-top: 0.5rem; color: #94a3b8; font-size: 0.75rem;">3 contracts per trade</div>
                    </div>
                </div>
            </div>
        </div>

        <div style="background: #1e293b; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <div style="font-weight: 600; color: #f1f5f9; margin-bottom: 0.75rem;">üìä CVD (Cumulative Volume Delta) Candlestick Chart</div>
            <div id="cvdChart" style="height: 180px; width: 100%;"></div>
        </div>

        <div style="background: #1e293b; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem;">
            <div style="font-weight: 600; color: #f1f5f9; margin-bottom: 0.75rem;">üìã Activity Log</div>
            <div id="activityLog" style="max-height: 180px; overflow-y: auto; font-family: monospace; font-size: 0.875rem; color: #94a3b8; line-height: 1.5;">
                <div style="color: #64748b;">Waiting for activity...</div>
            </div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
            <div style="background: #1e293b; border-radius: 0.5rem; padding: 1rem;">
                <div style="font-weight: 600; color: #f1f5f9; margin-bottom: 0.75rem;">üìä Current Position</div>
                <div id="positionPanel" style="color: #94a3b8; font-style: italic;">No active position</div>
            </div>

            <div style="background: #1e293b; border-radius: 0.5rem; padding: 1rem;">
                <div style="font-weight: 600; color: #f1f5f9; margin-bottom: 0.75rem;">üí∞ Recent Trades (Last 10)</div>
                <div id="tradesPanel" style="color: #94a3b8; font-size: 0.875rem;">No trades yet</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let socket = null;
        let chart = null;
        let candlestickSeries = null;
        let bosHighSeries = null;
        let bosLowSeries = null;
        let tradingEnabled = false;
        let currentPosition = null;
        let trades = [];
        let chartDataLoaded = false;
        let isUpdatingCharts = false;

        // Orderbook state
        let orderbookCanvas = null;
        let orderbookCtx = null;
        let marketDepthHub = null;
        let orderbookData = { bids: [], asks: [] };
        let orderbookAnimationFrame = null;

        // CVD state
        let cvdChart = null;
        let cvdSeries = null;
        let cvdData = [];
        let cumulativeDelta = 0;

        // Large order markers state
        let largeOrderCanvas = null;
        let largeOrderCtx = null;
        let largeOrdersData = [];
        let largeOrderAnimationFrame = null;
        let largeOrderThreshold = 30;

        // Volume profile (traded volume by price since 6pm ET session start)
        let volumeProfileCanvas = null;
        let volumeProfileCtx = null;
        let volumeProfileBins = new Map(); // Map<priceKey, { price, buyVol, sellVol, totalVol, lastUpdate }>
        const VOLUME_PROFILE_BIN_SIZE = 10; // 10-point price buckets
        const VOLUME_PROFILE_WINDOW_MS = 24 * 60 * 60 * 1000; // upper bound safety (24h), actual cutoff is session start

        // Absorption and exhaustion overlays (aggressive flow + drying up)
        let absorptionCanvas = null;
        let absorptionCtx = null;
        let absorptionZones = []; // { price, type: 'buy'|'sell', score, timestamp, aggVol, priceRange }
        let priceZones = new Map(); // Map<zoneKey, { aggBuyVol, aggSellVol, priceMin, priceMax, startTime }>
        const ZONE_RANGE_POINTS = 8; // +/- 8 points for NQ
        const ZONE_WINDOW_MS = 3000; // 3 second window
        let absorptionMinContracts = 50; // minimum aggressive volume in contracts for absorption

        let exhaustionCanvas = null;
        let exhaustionCtx = null;
        let exhaustionEvents = []; // { side: 'buy'|'sell', price, zone, swingDelta, intensityDrop, priceExtension, timestamp }
        let perSecondAggressiveBuckets = new Map(); // Map<timeSec, { time, buyVol, sellVol, high, low, lastPrice }>
        const EXHAUSTION_WINDOW_SEC = 5;
        const EXHAUSTION_LOOKBACK_SEC = EXHAUSTION_WINDOW_SEC * 2;
        let EXHAUSTION_MIN_PUSH_VOL = 50; // contracts in push window
        let EXHAUSTION_DROP_FACTOR = 0.4;
        let EXHAUSTION_MAX_EXTENSION_POINTS = 12;
        const EXHAUSTION_EVENT_COOLDOWN_MS = 60000;
        let exhaustionOverlayEnabled = true;

        // Configuration
        const config = {
            symbol: 'NQZ5',
            contractId: 'CON.F.US.ENQ.Z25',
            stopLossTicks: 4,
            tp1Ticks: 16,
            tp2Ticks: 32,
            contracts: 3,
        };

        // Initialize charts
        function initCharts() {
            console.log('Initializing charts...');
            const container = document.getElementById('mainChart');

            chart = LightweightCharts.createChart(container, {
                width: container.clientWidth,
                height: 450,
                layout: {
                    background: { type: LightweightCharts.ColorType.Solid, color: '#1e293b' },
                    textColor: '#94a3b8',
                },
                grid: {
                    vertLines: { color: 'rgba(14,23,38,0.4)' },
                    horzLines: { color: 'rgba(14,23,38,0.4)' },
                },
                timeScale: {
                    borderColor: '#334155',
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: {
                    borderColor: '#334155',
                },
            });

            candlestickSeries = chart.addCandlestickSeries({
                upColor: '#10b981',
                downColor: '#ef4444',
                borderUpColor: '#10b981',
                borderDownColor: '#ef4444',
                wickUpColor: '#10b981',
                wickDownColor: '#ef4444',
                lastPriceAnimation: LightweightCharts.LastPriceAnimationMode.Continuous,
            });

            // Add markers for BOS levels
            bosHighSeries = chart.addLineSeries({
                color: 'rgba(16, 185, 129, 0.5)',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                title: 'BOS High',
                priceLineVisible: false,
            });

            bosLowSeries = chart.addLineSeries({
                color: 'rgba(239, 68, 68, 0.5)',
                lineWidth: 1,
                lineStyle: LightweightCharts.LineStyle.Dashed,
                title: 'BOS Low',
                priceLineVisible: false,
            });

            // Initialize orderbook canvas
            initOrderbookCanvas();

            // Initialize CVD chart
            initCVDChart();

            // Initialize large order markers canvas
            initLargeOrderCanvas();

            // Initialize volume profile and absorption/exhaustion overlays
            initVolumeProfileCanvas();
            initAbsorptionCanvas();
            initExhaustionCanvas();

            // Handle window resize
            window.addEventListener('resize', () => {
                if (chart) {
                    chart.applyOptions({ width: container.clientWidth });
                    resizeOrderbookCanvas();
                    resizeLargeOrderCanvas();
                    resizeVolumeProfileCanvas();
                    resizeAbsorptionCanvas();
                    resizeExhaustionCanvas();
                }
                if (cvdChart) {
                    const cvdContainer = document.getElementById('cvdChart');
                    cvdChart.applyOptions({ width: cvdContainer.clientWidth });
                }
            });

            console.log('Charts initialized successfully');
        }

        // Initialize CVD chart
        function initCVDChart() {
            const container = document.getElementById('cvdChart');

            cvdChart = LightweightCharts.createChart(container, {
                width: container.clientWidth,
                height: 180,
                layout: {
                    background: { type: LightweightCharts.ColorType.Solid, color: '#1e293b' },
                    textColor: '#94a3b8',
                },
                grid: {
                    vertLines: { color: 'rgba(14,23,38,0.4)' },
                    horzLines: { color: 'rgba(14,23,38,0.4)' },
                },
                timeScale: {
                    borderColor: '#334155',
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: {
                    borderColor: '#334155',
                },
            });

            cvdSeries = cvdChart.addCandlestickSeries({
                upColor: '#10b981',
                downColor: '#ef4444',
                borderUpColor: '#10b981',
                borderDownColor: '#ef4444',
                wickUpColor: '#10b981',
                wickDownColor: '#ef4444',
            });

            console.log('CVD chart initialized');
        }

        // Volume profile canvas (left side, session-based from 6pm ET)
        function initVolumeProfileCanvas() {
            volumeProfileCanvas = document.getElementById('volumeProfileCanvas');
            if (!volumeProfileCanvas) {
                console.warn('‚ö†Ô∏è Volume profile canvas element not found');
                return;
            }
            volumeProfileCtx = volumeProfileCanvas.getContext('2d');
            resizeVolumeProfileCanvas();
            console.log('‚úÖ Volume profile canvas initialized');
        }

        function resizeVolumeProfileCanvas() {
            if (!volumeProfileCanvas || !volumeProfileCtx) return;
            const container = document.getElementById('mainChart');
            if (!container) return;
            volumeProfileCanvas.width = container.clientWidth;
            volumeProfileCanvas.height = container.clientHeight;
            if (chart && chartDataLoaded) {
                renderVolumeProfile();
            }
        }

        // Absorption overlay
        function initAbsorptionCanvas() {
            absorptionCanvas = document.getElementById('absorptionCanvas');
            if (!absorptionCanvas) {
                console.warn('‚ö†Ô∏è Absorption canvas element not found');
                return;
            }
            absorptionCtx = absorptionCanvas.getContext('2d');
            resizeAbsorptionCanvas();
            console.log('‚úÖ Absorption canvas initialized');
        }

        function resizeAbsorptionCanvas() {
            if (!absorptionCanvas || !absorptionCtx) return;
            const container = document.getElementById('mainChart');
            if (!container) return;
            absorptionCanvas.width = container.clientWidth;
            absorptionCanvas.height = container.clientHeight;
            if (chart && chartDataLoaded) {
                renderAbsorption();
            }
        }

        // Exhaustion overlay
        function initExhaustionCanvas() {
            exhaustionCanvas = document.getElementById('exhaustionCanvas');
            if (!exhaustionCanvas) {
                console.warn('‚ö†Ô∏è Exhaustion canvas element not found');
                return;
            }
            exhaustionCtx = exhaustionCanvas.getContext('2d');
            resizeExhaustionCanvas();
            console.log('‚úÖ Exhaustion canvas initialized');
        }

        function resizeExhaustionCanvas() {
            if (!exhaustionCanvas || !exhaustionCtx) return;
            const container = document.getElementById('mainChart');
            if (!container) return;
            exhaustionCanvas.width = container.clientWidth;
            exhaustionCanvas.height = container.clientHeight;
            if (chart && chartDataLoaded) {
                renderExhaustion();
            }
        }

        // Initialize large order markers canvas
        function initLargeOrderCanvas() {
            largeOrderCanvas = document.getElementById('largeOrderMarkers');
            largeOrderCtx = largeOrderCanvas.getContext('2d');
            resizeLargeOrderCanvas();

            // Start animation loop
            renderLargeOrderMarkers();

            // Listen to threshold changes
            document.getElementById('largeOrderThreshold').addEventListener('input', (e) => {
                largeOrderThreshold = parseInt(e.target.value) || 30;
                console.log('Large order threshold updated to:', largeOrderThreshold);
            });

            console.log('Large order markers initialized');
        }

        // Resize large order canvas to match main chart
        function resizeLargeOrderCanvas() {
            const container = document.getElementById('mainChart');
            largeOrderCanvas.width = container.clientWidth;
            largeOrderCanvas.height = container.clientHeight;
        }

        // Initialize orderbook canvas overlay
        function initOrderbookCanvas() {
            orderbookCanvas = document.getElementById('orderbookCanvas');
            orderbookCtx = orderbookCanvas.getContext('2d');
            resizeOrderbookCanvas();

            // Start animation loop
            renderOrderbook();
        }

        // Resize canvas to match chart
        function resizeOrderbookCanvas() {
            const container = document.getElementById('mainChart');
            orderbookCanvas.width = container.clientWidth;
            orderbookCanvas.height = container.clientHeight;
        }

        // Render orderbook visualization
        function renderOrderbook() {
            if (!orderbookCtx || !chart) {
                orderbookAnimationFrame = requestAnimationFrame(renderOrderbook);
                return;
            }

            // Clear canvas
            orderbookCtx.clearRect(0, 0, orderbookCanvas.width, orderbookCanvas.height);

            if (orderbookData.bids.length === 0 && orderbookData.asks.length === 0) {
                orderbookAnimationFrame = requestAnimationFrame(renderOrderbook);
                return;
            }

            try {
                // Get visible price range
                const timeScale = chart.timeScale();
                const priceScale = chart.priceScale('right');

                if (!timeScale || !priceScale) {
                    orderbookAnimationFrame = requestAnimationFrame(renderOrderbook);
                    return;
                }

                // Find max quantity for scaling
                const allQuantities = [
                    ...orderbookData.bids.map(b => b.quantity),
                    ...orderbookData.asks.map(a => a.quantity)
                ];
                const maxQuantity = Math.max(...allQuantities, 1);

                // Calculate bar width scaling (use 40% of chart width for max bar, similar to BTC dashboard)
                const maxBarWidth = orderbookCanvas.width * 0.4;

                // Draw bids (green, extending left from right side)
                orderbookCtx.fillStyle = 'rgba(16, 185, 129, 0.4)';
                orderbookData.bids.forEach(bid => {
                    const y = priceScale.priceToCoordinate(bid.price);
                    if (y !== null && y >= 0 && y <= orderbookCanvas.height) {
                        const barWidth = (bid.quantity / maxQuantity) * maxBarWidth;
                        const x = orderbookCanvas.width - barWidth;
                        orderbookCtx.fillRect(x, y - 4, barWidth, 8);
                    }
                });

                // Draw asks (red, extending left from right side)
                orderbookCtx.fillStyle = 'rgba(239, 68, 68, 0.4)';
                orderbookData.asks.forEach(ask => {
                    const y = priceScale.priceToCoordinate(ask.price);
                    if (y !== null && y >= 0 && y <= orderbookCanvas.height) {
                        const barWidth = (ask.quantity / maxQuantity) * maxBarWidth;
                        const x = orderbookCanvas.width - barWidth;
                        orderbookCtx.fillRect(x, y - 4, barWidth, 8);
                    }
                });

            } catch (error) {
                console.error('Error rendering orderbook:', error);
            }

            orderbookAnimationFrame = requestAnimationFrame(renderOrderbook);
        }

        // Render large order markers on price chart
        function renderLargeOrderMarkers() {
            if (!largeOrderCtx || !chart) {
                largeOrderAnimationFrame = requestAnimationFrame(renderLargeOrderMarkers);
                return;
            }

            // Clear canvas
            largeOrderCtx.clearRect(0, 0, largeOrderCanvas.width, largeOrderCanvas.height);

            if (largeOrdersData.length === 0) {
                largeOrderAnimationFrame = requestAnimationFrame(renderLargeOrderMarkers);
                return;
            }

            try {
                const priceScale = chart.priceScale('right');
                if (!priceScale) {
                    largeOrderAnimationFrame = requestAnimationFrame(renderLargeOrderMarkers);
                    return;
                }

                // Filter orders by threshold and render
                largeOrdersData
                    .filter(order => order.quantity >= largeOrderThreshold)
                    .forEach(order => {
                        const y = priceScale.priceToCoordinate(order.price);
                        if (y !== null && y >= 0 && y <= largeOrderCanvas.height) {
                            // Determine color based on side
                            const color = order.side === 'buy' ? '#10b981' : '#ef4444';
                            const bgColor = order.side === 'buy' ? 'rgba(16, 185, 129, 0.3)' : 'rgba(239, 68, 68, 0.3)';

                            // Draw circle (ball)
                            const radius = Math.min(12 + Math.log10(order.quantity) * 3, 20);
                            largeOrderCtx.beginPath();
                            largeOrderCtx.arc(largeOrderCanvas.width - 50, y, radius, 0, 2 * Math.PI);
                            largeOrderCtx.fillStyle = bgColor;
                            largeOrderCtx.fill();
                            largeOrderCtx.strokeStyle = color;
                            largeOrderCtx.lineWidth = 2;
                            largeOrderCtx.stroke();

                            // Draw quantity text
                            largeOrderCtx.fillStyle = color;
                            largeOrderCtx.font = 'bold 11px monospace';
                            largeOrderCtx.textAlign = 'center';
                            largeOrderCtx.textBaseline = 'middle';
                            largeOrderCtx.fillText(order.quantity.toString(), largeOrderCanvas.width - 50, y);
                        }
                    });

            } catch (error) {
                console.error('Error rendering large order markers:', error);
            }

            largeOrderAnimationFrame = requestAnimationFrame(renderLargeOrderMarkers);
        }

        // Helper: price bin key for volume profile
        function getVolumeProfileKey(price) {
            return Math.floor(price / VOLUME_PROFILE_BIN_SIZE) * VOLUME_PROFILE_BIN_SIZE;
        }

        // Session start at 6pm local time (treated as ET on an ET machine)
        function getSessionStartMs(referenceMs) {
            const now = new Date(referenceMs || Date.now());
            const year = now.getFullYear();
            const month = now.getMonth();
            const date = now.getDate();

            const sessionStartToday = new Date(year, month, date, 18, 0, 0, 0);
            if (now.getTime() >= sessionStartToday.getTime()) {
                return sessionStartToday.getTime();
            }

            const sessionStartPrev = new Date(year, month, date - 1, 18, 0, 0, 0);
            return sessionStartPrev.getTime();
        }

        function updateVolumeProfile(price, quantity, side, timestampMs) {
            if (!Number.isFinite(price) || !Number.isFinite(quantity) || quantity <= 0) return;
            if (!volumeProfileBins) {
                volumeProfileBins = new Map();
            }

            const sessionStart = getSessionStartMs(timestampMs);
            if (timestampMs < sessionStart) {
                return;
            }

            const key = getVolumeProfileKey(price);
            const existing = volumeProfileBins.get(key) || {
                price: key,
                buyVol: 0,
                sellVol: 0,
                totalVol: 0,
                lastUpdate: timestampMs
            };

            if (side === 'buy') {
                existing.buyVol += quantity;
            } else if (side === 'sell') {
                existing.sellVol += quantity;
            }
            existing.totalVol = existing.buyVol + existing.sellVol;
            existing.lastUpdate = timestampMs;

            volumeProfileBins.set(key, existing);
            cleanupVolumeProfile(timestampMs);
            renderVolumeProfile();
        }

        function cleanupVolumeProfile(nowMs) {
            if (!volumeProfileBins) return;
            const sessionStart = getSessionStartMs(nowMs);
            for (const [key, bin] of volumeProfileBins.entries()) {
                if (!bin || bin.lastUpdate < sessionStart) {
                    volumeProfileBins.delete(key);
                }
            }
        }

        // Maintain per-second buckets of aggressive flow for exhaustion detection
        function updateAggressiveBuckets(timeSec, price, quantity, side) {
            if (!Number.isFinite(timeSec) || !Number.isFinite(price) || !Number.isFinite(quantity)) return;
            if (!side) return;

            if (!perSecondAggressiveBuckets.has(timeSec)) {
                perSecondAggressiveBuckets.set(timeSec, {
                    time: timeSec,
                    buyVol: 0,
                    sellVol: 0,
                    high: price,
                    low: price,
                    lastPrice: price
                });
            }

            const bucket = perSecondAggressiveBuckets.get(timeSec);
            if (!bucket) return;

            if (side === 'buy') {
                bucket.buyVol += quantity;
            } else if (side === 'sell') {
                bucket.sellVol += quantity;
            }

            bucket.high = Math.max(bucket.high, price);
            bucket.low = Math.min(bucket.low, price);
            bucket.lastPrice = price;

            cleanupOldAggressiveBuckets(timeSec);
            detectExhaustion(timeSec);
        }

        function cleanupOldAggressiveBuckets(currentTimeSec) {
            const cutoff = currentTimeSec - (EXHAUSTION_LOOKBACK_SEC + 10);
            for (const [key, bucket] of perSecondAggressiveBuckets.entries()) {
                if (!bucket || bucket.time < cutoff) {
                    perSecondAggressiveBuckets.delete(key);
                }
            }
        }

        // Track aggressive volume in price zones for absorption
        function getZoneKey(price) {
            return Math.floor(price / ZONE_RANGE_POINTS) * ZONE_RANGE_POINTS;
        }

        function processAggressiveTrade(price, quantity, side) {
            if (!price || !quantity || !side) return;
            const zoneKey = getZoneKey(price);
            const now = Date.now();

            if (!priceZones.has(zoneKey)) {
                priceZones.set(zoneKey, {
                    aggBuyVol: 0,
                    aggSellVol: 0,
                    priceMin: price,
                    priceMax: price,
                    startTime: now
                });
            }

            const zone = priceZones.get(zoneKey);
            if (!zone) return;

            if (side === 'buy') {
                zone.aggBuyVol += quantity;
            } else {
                zone.aggSellVol += quantity;
            }

            zone.priceMin = Math.min(zone.priceMin, price);
            zone.priceMax = Math.max(zone.priceMax, price);

            const elapsed = now - zone.startTime;
            if (elapsed >= ZONE_WINDOW_MS) {
                detectAbsorption(zoneKey, zone);
                priceZones.delete(zoneKey);
            }
        }

        function detectAbsorption(zoneKey, zone) {
            const buyAbsorption = zone.aggBuyVol >= absorptionMinContracts;
            const sellAbsorption = zone.aggSellVol >= absorptionMinContracts;

            if (!buyAbsorption && !sellAbsorption) return;

            const priceMovement = zone.priceMax - zone.priceMin;
            const expectedMovement = ZONE_RANGE_POINTS;
            const score = Math.max(zone.aggBuyVol, zone.aggSellVol) / (1 + priceMovement / expectedMovement);

            if (buyAbsorption && priceMovement < ZONE_RANGE_POINTS * 0.5) {
                const absorption = {
                    price: zoneKey,
                    type: 'sell',
                    score,
                    timestamp: Date.now(),
                    aggVol: zone.aggBuyVol,
                    priceRange: priceMovement
                };
                absorptionZones.push(absorption);
                console.log(`üü• BUY ABSORPTION (Resistance) @ ${zoneKey} | ${zone.aggBuyVol.toFixed(0)} contracts | score=${score.toFixed(2)}`);
            }

            if (sellAbsorption && priceMovement < ZONE_RANGE_POINTS * 0.5) {
                const absorption = {
                    price: zoneKey,
                    type: 'buy',
                    score,
                    timestamp: Date.now(),
                    aggVol: zone.aggSellVol,
                    priceRange: priceMovement
                };
                absorptionZones.push(absorption);
                console.log(`üü¶ SELL ABSORPTION (Support) @ ${zoneKey} | ${zone.aggSellVol.toFixed(0)} contracts | score=${score.toFixed(2)}`);
            }

            const cutoffTime = Date.now() - (30 * 60 * 1000);
            absorptionZones = absorptionZones.filter(a => a.timestamp >= cutoffTime);

            if (buyAbsorption || sellAbsorption) {
                renderAbsorption();
            }
        }

        // Setup market depth via Socket.IO (proxied through backend)
        function setupMarketDepth() {
            socket.on('market_depth', (depth) => {
                // Parse depth data
                // TopstepX format: { bids: [[price, quantity], ...], asks: [[price, quantity], ...] }
                if (depth && depth.bids && depth.asks) {
                    orderbookData.bids = depth.bids.map(([price, quantity]) => ({ price, quantity }));
                    orderbookData.asks = depth.asks.map(([price, quantity]) => ({ price, quantity }));

                    // Update large orders data (combine bids and asks with side info)
                    largeOrdersData = [
                        ...depth.bids.map(([price, quantity]) => ({ price, quantity, side: 'buy' })),
                        ...depth.asks.map(([price, quantity]) => ({ price, quantity, side: 'sell' }))
                    ];
                }
            });

            // Setup trade data listener for CVD + volume profile + aggression overlays
            socket.on('trade_data', (trade) => {
                if (!trade || !trade.price || !trade.quantity) return;

                const price = Number(trade.price);
                const quantity = Number(trade.quantity);
                const side = trade.aggressor === 'buy' ? 'buy' : 'sell';
                const tsMs = trade.timestamp || Date.now();

                // Update cumulative delta based on trade aggressor
                // If trade is at ask (buyer aggressive), delta increases
                // If trade is at bid (seller aggressive), delta decreases
                const delta = side === 'buy' ? quantity : -quantity;
                cumulativeDelta += delta;

                // Get current bar timestamp (rounded to 1 minute)
                const timestamp = Math.floor(Date.now() / 60000) * 60000;
                const time = Math.floor(timestamp / 1000);

                // Find or create CVD bar for this minute
                let cvdBar = cvdData.find(bar => bar.time === time);
                if (!cvdBar) {
                    cvdBar = {
                        time,
                        open: cumulativeDelta,
                        high: cumulativeDelta,
                        low: cumulativeDelta,
                        close: cumulativeDelta
                    };
                    cvdData.push(cvdBar);
                } else {
                    cvdBar.close = cumulativeDelta;
                    cvdBar.high = Math.max(cvdBar.high, cumulativeDelta);
                    cvdBar.low = Math.min(cvdBar.low, cumulativeDelta);
                }

                // Update CVD chart
                if (cvdSeries && cvdBar) {
                    cvdData.sort((a, b) => a.time - b.time);
                    cvdSeries.setData(cvdData);
                    if (cvdChart) {
                        cvdChart.timeScale().fitContent();
                    }
                }

                // Update volume profile and aggression overlays
                updateVolumeProfile(price, quantity, side, tsMs);
                processAggressiveTrade(price, quantity, side);
                const bucketTime = Math.floor(tsMs / 1000);
                updateAggressiveBuckets(bucketTime, price, quantity, side);
            });

            console.log('Market depth listener setup complete');
            addActivityLog('Level 2 orderbook connected via Socket.IO', 'success');
        }

        // Absorption rendering
        function renderAbsorption() {
            if (!absorptionCanvas || !absorptionCtx || !chart || !candlestickSeries) {
                return;
            }

            absorptionCtx.clearRect(0, 0, absorptionCanvas.width, absorptionCanvas.height);

            if (!absorptionZones || absorptionZones.length === 0) {
                return;
            }

            let drawn = 0;

            for (const absorption of absorptionZones) {
                if (!absorption) continue;
                const y = candlestickSeries.priceToCoordinate(absorption.price);
                if (y == null) continue;

                const isBuy = absorption.type === 'buy';
                absorptionCtx.strokeStyle = isBuy ? '#3b82f6' : '#ef4444';
                absorptionCtx.fillStyle = isBuy ? 'rgba(59, 130, 246, 0.10)' : 'rgba(239, 68, 68, 0.10)';
                absorptionCtx.lineWidth = 2;

                const width = 60;
                const height = 18;
                const x = absorptionCanvas.width - 80;

                absorptionCtx.beginPath();
                absorptionCtx.rect(x, y - height / 2, width, height);
                absorptionCtx.fill();
                absorptionCtx.stroke();

                absorptionCtx.fillStyle = isBuy ? '#3b82f6' : '#ef4444';
                absorptionCtx.font = 'bold 10px monospace';
                absorptionCtx.textAlign = 'right';
                absorptionCtx.textBaseline = 'middle';
                const label = `${isBuy ? '‚Üë' : '‚Üì'} ${absorption.aggVol.toFixed(0)}`;
                absorptionCtx.fillText(label, x + width - 4, y);

                drawn++;
            }

            if (drawn === 0) {
                return;
            }
        }

        // Exhaustion detection and rendering
        function detectExhaustion(currentTimeSec) {
            if (!chart || !candlestickSeries) return;

            const startTime = currentTimeSec - EXHAUSTION_LOOKBACK_SEC;
            const buckets = Array.from(perSecondAggressiveBuckets.values())
                .filter(b => b && b.time >= startTime && b.time <= currentTimeSec)
                .sort((a, b) => a.time - b.time);

            if (buckets.length < EXHAUSTION_LOOKBACK_SEC) {
                return;
            }

            const splitTime = currentTimeSec - EXHAUSTION_WINDOW_SEC;
            const pushBuckets = buckets.filter(b => b.time < splitTime);
            const retestBuckets = buckets.filter(b => b.time >= splitTime);

            if (pushBuckets.length === 0 || retestBuckets.length === 0) {
                return;
            }

            const pushBuyVol = pushBuckets.reduce((sum, b) => sum + (b.buyVol || 0), 0);
            const pushSellVol = pushBuckets.reduce((sum, b) => sum + (b.sellVol || 0), 0);
            const retestBuyVol = retestBuckets.reduce((sum, b) => sum + (b.buyVol || 0), 0);
            const retestSellVol = retestBuckets.reduce((sum, b) => sum + (b.sellVol || 0), 0);

            const pushHigh = Math.max(...pushBuckets.map(b => b.high));
            const pushLow = Math.min(...pushBuckets.map(b => b.low));
            const retestHigh = Math.max(...retestBuckets.map(b => b.high));
            const retestLow = Math.min(...retestBuckets.map(b => b.low));
            const lastBucket = buckets[buckets.length - 1];
            const lastPriceLocal = lastBucket.lastPrice;

            const pushRange = Math.max(pushHigh - pushLow, 0.25);
            const retestRange = Math.max(retestHigh - retestLow, 0.25);

            const pushBuyIntensity = pushBuyVol / pushRange;
            const pushSellIntensity = pushSellVol / pushRange;
            const retestBuyIntensity = retestBuyVol / retestRange;
            const retestSellIntensity = retestSellVol / retestRange;

            const buyIntensityDrop = pushBuyIntensity > 0 ? (retestBuyIntensity / pushBuyIntensity) : 1;
            const sellIntensityDrop = pushSellIntensity > 0 ? (retestSellIntensity / pushSellIntensity) : 1;

            const buyDeltaPush = pushBuyVol - pushSellVol;
            const buyDeltaRetest = retestBuyVol - retestSellVol;
            const sellDeltaPush = pushSellVol - pushBuyVol;
            const sellDeltaRetest = retestSellVol - retestBuyVol;

            const priceExtensionUp = retestHigh - pushHigh;
            const priceExtensionDown = pushLow - retestLow;

            if (
                pushBuyVol >= EXHAUSTION_MIN_PUSH_VOL &&
                buyIntensityDrop < EXHAUSTION_DROP_FACTOR &&
                priceExtensionUp <= EXHAUSTION_MAX_EXTENSION_POINTS &&
                lastPriceLocal >= pushHigh - EXHAUSTION_MAX_EXTENSION_POINTS &&
                buyDeltaPush > 0 &&
                buyDeltaRetest <= buyDeltaPush
            ) {
                const level = retestHigh;
                maybeAddExhaustionEvent({
                    side: 'sell',
                    price: level,
                    zone: { low: pushLow, high: retestHigh },
                    swingDelta: { push: buyDeltaPush, retest: buyDeltaRetest },
                    intensityDrop: buyIntensityDrop,
                    priceExtension: priceExtensionUp,
                    timestamp: Date.now()
                });
            }

            if (
                pushSellVol >= EXHAUSTION_MIN_PUSH_VOL &&
                sellIntensityDrop < EXHAUSTION_DROP_FACTOR &&
                priceExtensionDown <= EXHAUSTION_MAX_EXTENSION_POINTS &&
                lastPriceLocal <= pushLow + EXHAUSTION_MAX_EXTENSION_POINTS &&
                sellDeltaPush > 0 &&
                sellDeltaRetest <= sellDeltaPush
            ) {
                const level = retestLow;
                maybeAddExhaustionEvent({
                    side: 'buy',
                    price: level,
                    zone: { low: retestLow, high: pushHigh },
                    swingDelta: { push: sellDeltaPush, retest: sellDeltaRetest },
                    intensityDrop: sellIntensityDrop,
                    priceExtension: priceExtensionDown,
                    timestamp: Date.now()
                });
            }
        }

        function maybeAddExhaustionEvent(event) {
            if (!event || !Number.isFinite(event.price)) return;

            const now = event.timestamp || Date.now();
            const recentExisting = exhaustionEvents.find(e =>
                Math.abs(e.price - event.price) <= ZONE_RANGE_POINTS &&
                Math.abs(now - e.timestamp) <= EXHAUSTION_EVENT_COOLDOWN_MS
            );

            if (recentExisting) {
                return;
            }

            exhaustionEvents.push(event);

            const cutoff = now - (30 * 60 * 1000);
            exhaustionEvents = exhaustionEvents.filter(e => e.timestamp >= cutoff);

            console.log(`üí® EXHAUSTION ${event.side.toUpperCase()} @ ${event.price.toFixed(2)} | drop=${event.intensityDrop.toFixed(2)} | ext=${event.priceExtension.toFixed(2)}`);

            renderExhaustion();
        }

        function renderExhaustion() {
            if (!exhaustionCanvas || !exhaustionCtx || !chart || !candlestickSeries) {
                return;
            }

            exhaustionCtx.clearRect(0, 0, exhaustionCanvas.width, exhaustionCanvas.height);

            if (!exhaustionOverlayEnabled || !exhaustionEvents || exhaustionEvents.length === 0) {
                return;
            }

            let drawn = 0;

            for (const event of exhaustionEvents) {
                if (!event) continue;

                const y = candlestickSeries.priceToCoordinate(event.price);
                if (y == null) continue;

                const isBuyZone = event.side === 'buy';
                exhaustionCtx.strokeStyle = isBuyZone ? '#22c55e' : '#f97316';
                exhaustionCtx.fillStyle = isBuyZone ? 'rgba(34, 197, 94, 0.10)' : 'rgba(249, 115, 22, 0.10)';
                exhaustionCtx.lineWidth = 2;

                const width = 70;
                const height = 16;
                const x = exhaustionCanvas.width - 160;

                exhaustionCtx.beginPath();
                exhaustionCtx.rect(x, y - height / 2, width, height);
                exhaustionCtx.fill();
                exhaustionCtx.stroke();

                exhaustionCtx.fillStyle = isBuyZone ? '#22c55e' : '#f97316';
                exhaustionCtx.font = 'bold 10px monospace';
                exhaustionCtx.textAlign = 'left';
                exhaustionCtx.textBaseline = 'middle';

                const labelSide = isBuyZone ? 'B' : 'S';
                const labelDrop = event.intensityDrop != null ? (event.intensityDrop).toFixed(2) : '';
                const label = `Ex${labelSide} ${labelDrop}`;
                exhaustionCtx.fillText(label, x + 4, y);

                drawn++;
            }
        }
        function renderVolumeProfile() {
            if (!volumeProfileCanvas || !volumeProfileCtx || !chart || !candlestickSeries) {
                return;
            }

            volumeProfileCtx.clearRect(0, 0, volumeProfileCanvas.width, volumeProfileCanvas.height);

            if (!volumeProfileBins || volumeProfileBins.size === 0) {
                return;
            }

            const bins = Array.from(volumeProfileBins.values()).sort((a, b) => a.price - b.price);
            if (bins.length === 0) return;

            const maxVol = bins.reduce((max, bin) => Math.max(max, bin.totalVol || 0), 0) || 1;
            const maxBarWidth = volumeProfileCanvas.width * 0.25;

            for (const bin of bins) {
                if (!bin || !Number.isFinite(bin.price)) continue;

                const y = candlestickSeries.priceToCoordinate(bin.price);
                if (y == null || y < -50 || y > volumeProfileCanvas.height + 50) continue;

                const width = Math.max((bin.totalVol / maxVol) * maxBarWidth, 2);
                const x = 4;
                const barHeight = 6;

                const buyVol = bin.buyVol || 0;
                const sellVol = bin.sellVol || 0;
                const net = buyVol - sellVol;

                let color;
                if (net > 0) {
                    color = 'rgba(34, 197, 94, 0.7)';
                } else if (net < 0) {
                    color = 'rgba(248, 113, 113, 0.7)';
                } else {
                    color = 'rgba(148, 163, 184, 0.6)';
                }

                volumeProfileCtx.fillStyle = color;
                volumeProfileCtx.fillRect(x, y - barHeight / 2, width, barHeight);
            }
        }

        // Update charts with data
        async function updateCharts(data) {
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.log('No data to update charts');
                return;
            }

            // If charts aren't initialized yet, wait and retry
            if (!chart || !candlestickSeries) {
                console.log('Charts not initialized yet, retrying in 200ms...');
                setTimeout(() => updateCharts(data), 200);
                return;
            }

            // Prevent concurrent updates
            if (isUpdatingCharts) {
                console.log('Charts are already being updated, skipping...');
                return;
            }

            isUpdatingCharts = true;
            console.log('Starting chart update with', data.length, 'bars');

            try {
                // Prepare and validate candle data
                console.log('Processing', data.length, 'bars, first bar:', data[0]);

                const candleData = data
                    .map(point => {
                        // Try to process the point, log any issues
                        try {
                            if (!point) {
                                console.warn('Null/undefined point');
                                return null;
                            }

                            const timestamp = point.timestamp || point.time;
                            if (!timestamp) {
                                console.warn('No timestamp in point:', point);
                                return null;
                            }

                            // Convert all values to numbers
                            const open = parseFloat(point.open);
                            const high = parseFloat(point.high);
                            const low = parseFloat(point.low);
                            const close = parseFloat(point.close);

                            // Check if all are valid numbers
                            if (!Number.isFinite(open) || !Number.isFinite(high) || !Number.isFinite(low) || !Number.isFinite(close)) {
                                console.warn('Invalid OHLC values:', {open, high, low, close});
                                return null;
                            }

                            return {
                                time: Math.floor(new Date(timestamp).getTime() / 1000),
                                open, high, low, close
                            };
                        } catch (e) {
                            console.warn('Error processing point:', point, e);
                            return null;
                        }
                    })
                    .filter(point => point !== null)
                    .sort((a, b) => a.time - b.time);

                console.log('After mapping and filtering:', candleData.length, 'valid bars');

                if (candleData.length > 0 && candlestickSeries) {
                    candlestickSeries.setData(candleData);
                    console.log('Set candlestick data:', candleData.length, 'bars');

                    // Add markers for wicked candles and entry signals
                    const markers = data
                        .filter(bar => bar.wickedBullish || bar.wickedBearish || bar.entrySignal)
                        .map(bar => {
                            const time = Math.floor(new Date(bar.timestamp).getTime() / 1000);
                            if (bar.entrySignal) {
                                return {
                                    time,
                                    position: bar.entrySignal === 'long' ? 'belowBar' : 'aboveBar',
                                    color: bar.entrySignal === 'long' ? '#10b981' : '#ef4444',
                                    shape: 'arrowUp',
                                    text: bar.entrySignal === 'long' ? 'LONG' : 'SHORT',
                                };
                            } else {
                                return {
                                    time,
                                    position: 'aboveBar',
                                    color: bar.wickedBullish ? '#10b981' : '#ef4444',
                                    shape: 'circle',
                                    text: bar.wickedBullish ? 'W+' : 'W-',
                                };
                            }
                        });

                    if (markers.length > 0) {
                        candlestickSeries.setMarkers(markers);
                        console.log('Set markers:', markers.length);
                    }

                    // Update BOS levels
                    const bosHighData = data
                        .filter(point => point && typeof point.bosHigh === 'number' && Number.isFinite(point.bosHigh))
                        .map(point => ({
                            time: Math.floor(new Date(point.timestamp).getTime() / 1000),
                            value: point.bosHigh
                        }))
                        .sort((a, b) => a.time - b.time);

                    if (bosHighData.length > 0 && bosHighSeries) {
                        bosHighSeries.setData(bosHighData);
                        console.log('Set BOS high data:', bosHighData.length, 'points');
                    }

                    const bosLowData = data
                        .filter(point => point && typeof point.bosLow === 'number' && Number.isFinite(point.bosLow))
                        .map(point => ({
                            time: Math.floor(new Date(point.timestamp).getTime() / 1000),
                            value: point.bosLow
                        }))
                        .sort((a, b) => a.time - b.time);

                    if (bosLowData.length > 0 && bosLowSeries) {
                        bosLowSeries.setData(bosLowData);
                        console.log('Set BOS low data:', bosLowData.length, 'points');
                    }

                    // Fit chart after all series are set
                    chart.timeScale().fitContent();
                    console.log('Chart fitted to content');

                    console.log('Chart update complete');
                    // ONLY set flag when we actually have data
                    chartDataLoaded = true;
                } else {
                    console.log('No valid candleData to render - skipping chart data load');
                }
            } catch (error) {
                console.error('Error updating charts:', error);
            } finally {
                isUpdatingCharts = false;
            }
        }

        // Update UI with status
        function updateStatus(data) {
            if (!data) {
                console.log('No status data to update');
                return;
            }

            console.log('Updating status:', data);

            // Update trading status
            if (data.isTrading != null) {
                tradingEnabled = data.isTrading;
                const statusEl = document.getElementById('tradingStatus');
                statusEl.textContent = tradingEnabled ? 'LIVE' : 'OFFLINE';
                statusEl.className = tradingEnabled ? 'status-badge status-active' : 'status-badge status-inactive';

                document.getElementById('btnStart').style.display = tradingEnabled ? 'none' : 'block';
                document.getElementById('btnStop').style.display = tradingEnabled ? 'block' : 'none';
                console.log('Trading status:', tradingEnabled ? 'LIVE' : 'OFFLINE');
            }

            // Update stats
            if (data.accountStats) {
                const stats = data.accountStats;
                document.getElementById('totalTrades').textContent = stats.totalTrades || 0;
                document.getElementById('winRate').textContent = (stats.winRate || 0) + '%';

                const pnlElement = document.getElementById('totalPnL');
                pnlElement.textContent = '$' + (stats.totalPnL || 0).toFixed(2);
                pnlElement.className = 'stat-value ' + (stats.totalPnL >= 0 ? 'positive' : 'negative');

                console.log('Stats updated - Trades:', stats.totalTrades, 'Win Rate:', stats.winRate + '%', 'P&L:', stats.totalPnL);
            }

            // Update position info
            if (data.position) {
                currentPosition = data.position;
                document.getElementById('entryPrice').textContent = '$' + data.position.entryPrice.toFixed(2);
                document.getElementById('positionStatus').innerHTML = `<span style="color: ${data.position.side === 'long' ? '#10b981' : '#ef4444'}">${data.position.side.toUpperCase()}</span>`;

                const unrealizedEl = document.getElementById('unrealizedPnL');
                unrealizedEl.textContent = '$' + (data.position.unrealizedPnL || 0).toFixed(2);
                unrealizedEl.className = 'stat-value ' + ((data.position.unrealizedPnL || 0) >= 0 ? 'positive' : 'negative');

                updatePositionPanel(data.position);
                console.log('Position updated:', data.position.side, '@', data.position.entryPrice, 'Unrealized P&L:', data.position.unrealizedPnL);
            } else {
                currentPosition = null;
                document.getElementById('entryPrice').textContent = '‚Äî';
                document.getElementById('positionStatus').textContent = 'NONE';
                document.getElementById('unrealizedPnL').textContent = '$0';
                document.getElementById('unrealizedPnL').className = 'stat-value';
                document.getElementById('positionPanel').innerHTML = '<div style="color: #94a3b8; font-style: italic;">No active position</div>';
                console.log('No active position');
            }

            // Update recent trades
            if (data.closedTrades) {
                trades = data.closedTrades;
                updateTradesPanel(data.closedTrades);
                console.log('Trades updated:', data.closedTrades.length, 'total');
            }
        }

        // Update position panel
        function updatePositionPanel(position) {
            if (!position) return;

            const html = `
                <div class="position-row">
                    <div>
                        <div class="position-label">Entry</div>
                        <div class="position-value">$${position.entryPrice.toFixed(2)}</div>
                    </div>
                    <div>
                        <div class="position-label">Pattern</div>
                        <div class="position-value">${position.entryPattern || 'ICT'}</div>
                    </div>
                </div>
                <div class="position-row">
                    <div>
                        <div class="position-label">Stop Loss</div>
                        <div class="position-value">$${position.stopLoss.toFixed(2)}</div>
                    </div>
                    <div>
                        <div class="position-label">TP1 / TP2</div>
                        <div class="position-value">$${position.targetTP1.toFixed(2)} / $${position.targetTP2.toFixed(2)}</div>
                    </div>
                </div>
                <div class="position-row">
                    <div>
                        <div class="position-label">Contracts</div>
                        <div class="position-value">${position.totalQty || position.contracts || 3}</div>
                    </div>
                    <div>
                        <div class="position-label">Unrealized</div>
                        <div class="position-value" style="color: ${(position.unrealizedPnL || 0) > 0 ? '#10b981' : '#ef4444'}">$${(position.unrealizedPnL || 0).toFixed(2)}</div>
                    </div>
                </div>
            `;
            document.getElementById('positionPanel').innerHTML = html;
        }

        // Update trades panel
        function updateTradesPanel(closedTrades) {
            if (!closedTrades || closedTrades.length === 0) {
                document.getElementById('tradesPanel').innerHTML = '<div style="color: #94a3b8;">No trades yet</div>';
                return;
            }

            const html = closedTrades.slice(-10).reverse().map(trade => `
                <div class="trade-row">
                    <div class="trade-side ${trade.side === 'long' ? 'long' : 'short'}">${trade.side.slice(0, 1).toUpperCase()}</div>
                    <div class="trade-pnl ${trade.pnl > 0 ? 'positive' : 'negative'}">${trade.pnl > 0 ? '+' : ''}$${Math.abs(trade.pnl).toFixed(0)}</div>
                    <div class="trade-info">${(trade.exitReason || 'CLOSED').toUpperCase()} @ $${trade.exitPrice.toFixed(2)}</div>
                </div>
            `).join('');

            document.getElementById('tradesPanel').innerHTML = html;
        }

        // Add activity log entry
        function addActivityLog(message, type = 'info') {
            const logEl = document.getElementById('activityLog');
            if (!logEl) return;

            // Clear "Waiting for activity..." message on first log
            if (logEl.children.length === 1 && logEl.textContent.includes('Waiting for activity')) {
                logEl.innerHTML = '';
            }

            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                info: '#94a3b8',
                success: '#22c55e',
                warning: '#eab308',
                error: '#ef4444'
            };

            const entry = document.createElement('div');
            entry.style.color = colors[type] || colors.info;
            entry.style.marginBottom = '4px';
            entry.style.padding = '0.25rem 0';
            entry.style.borderBottom = '1px solid rgba(100, 116, 139, 0.2)';
            entry.textContent = `[${timestamp}] ${message}`;

            logEl.appendChild(entry);

            // Keep only last 50 entries
            while (logEl.children.length > 50) {
                logEl.removeChild(logEl.firstChild);
            }

            // Auto-scroll to bottom
            logEl.scrollTop = logEl.scrollHeight;

            console.log('[ACTIVITY LOG]', type.toUpperCase(), ':', message);
        }

        // Socket connection
        function connect() {
            console.log('Initiating Socket.IO connection...');

            socket = io({
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: 5,
            });

            socket.on('connect', () => {
                console.log('Connected to trading server');
                addActivityLog('Connected to trading server', 'success');
                document.getElementById('btnStart').disabled = false;

                // Request initial chart history
                console.log('Requesting chart history...');
                socket.emit('request_chart_history');

                // Setup orderbook via Socket.IO
                setupMarketDepth();
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                addActivityLog('Disconnected from server', 'error');
                document.getElementById('tradingStatus').textContent = 'OFFLINE';
                document.getElementById('tradingStatus').classList.remove('status-active');
                document.getElementById('tradingStatus').classList.add('status-inactive');
            });

            socket.on('chartHistory', (data) => {
                console.log('Received chart history via socket:', data ? data.length : 0, 'bars');
                if (chartDataLoaded) {
                    console.log('Chart data already loaded, ignoring duplicate socket data');
                    return;
                }
                if (data && data.length > 0) {
                    updateCharts(data);
                    addActivityLog(`Loaded ${data.length} historical bars`, 'info');
                } else {
                    console.warn('Chart history is empty or invalid');
                }
            });

            socket.on('bar', (bar) => {
                console.log('Received live bar update:', bar);

                // Update with the new bar using update() instead of setData()
                if (candlestickSeries && bar) {
                    const candleData = {
                        time: Math.floor(new Date(bar.timestamp).getTime() / 1000),
                        open: bar.open,
                        high: bar.high,
                        low: bar.low,
                        close: bar.close
                    };
                    candlestickSeries.update(candleData);
                    console.log('Updated candlestick with live data');

                    // Update BOS levels
                    if (bar.bosHigh != null && bosHighSeries) {
                        bosHighSeries.update({
                            time: candleData.time,
                            value: bar.bosHigh
                        });
                        console.log('Updated BOS high:', bar.bosHigh);
                    }
                    if (bar.bosLow != null && bosLowSeries) {
                        bosLowSeries.update({
                            time: candleData.time,
                            value: bar.bosLow
                        });
                        console.log('Updated BOS low:', bar.bosLow);
                    }

                    // Log special candle patterns
                    if (bar.wickedBullish) {
                        addActivityLog('Wicked Bullish candle detected', 'info');
                    }
                    if (bar.wickedBearish) {
                        addActivityLog('Wicked Bearish candle detected', 'info');
                    }
                    if (bar.entrySignal) {
                        addActivityLog(`Entry signal: ${bar.entrySignal.toUpperCase()}`, 'success');
                    }
                }
            });

            socket.on('tick', (tick) => {
                // Update the current bar with live tick data (no indicators, just OHLC)
                if (candlestickSeries && tick) {
                    const candleData = {
                        time: Math.floor(new Date(tick.timestamp).getTime() / 1000),
                        open: tick.open,
                        high: tick.high,
                        low: tick.low,
                        close: tick.close
                    };
                    candlestickSeries.update(candleData);
                }
            });

            socket.on('status', (data) => {
                console.log('Received status update:', data);
                updateStatus(data);
            });

            socket.on('trade', (trade) => {
                console.log('Trade closed:', trade);
                trades.push(trade);
                updateTradesPanel(trades);

                const resultMsg = `Trade closed: ${trade.side.toUpperCase()} ${trade.pnl >= 0 ? 'WIN' : 'LOSS'} $${trade.pnl.toFixed(2)}`;
                addActivityLog(resultMsg, trade.pnl >= 0 ? 'success' : 'error');
            });

            socket.on('log', (data) => {
                console.log('[LOG EVENT] Received log event:', data);
                addActivityLog(data.message, data.type || 'info');
            });

            socket.on('config', (data) => {
                Object.assign(config, data);
                console.log('Received config:', config);
                addActivityLog('Configuration updated', 'info');
            });

            socket.on('error', (error) => {
                console.error('Socket error:', error);
                addActivityLog(`Error: ${error}`, 'error');
            });
        }

        // Event handlers
        document.getElementById('btnStart').addEventListener('click', () => {
            console.log('Start trading button clicked');
            socket.emit('start_trading');
            addActivityLog('Starting trading...', 'info');
        });

        document.getElementById('btnStop').addEventListener('click', () => {
            console.log('Stop trading button clicked');
            socket.emit('stop_trading');
            addActivityLog('Stopping trading...', 'warning');
        });

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing dashboard...');
            initCharts();
            connect();

            addActivityLog('Dashboard initialized', 'info');
        });
    </script>
</body>
</html>
